/**
 * Copyright (c) 2013-2014 INRIX, Inc.
 * 
 * INRIX is a registered trademark of INRIX, Inc. Any copyright, patent and
 * trademark notice(s) contained herein or in related code, files or
 * documentation shall not be altered and shall be included in all copies and
 * substantial portions of the software.
 */

package com.inrix.reference.trafficapp.incidents;

import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteQueryBuilder;
import android.os.Handler;
import android.os.Looper;
import android.provider.BaseColumns;
import android.text.TextUtils;

import com.google.gson.Gson;
import com.inrix.reference.trafficapp.TrafficApp;
import com.inrix.reference.trafficapp.util.DateUtils;
import com.inrix.sdk.Error;
import com.inrix.sdk.ICancellable;
import com.inrix.sdk.IncidentsManager;
import com.inrix.sdk.InrixCore;
import com.inrix.sdk.model.Incident;
import com.inrix.sdk.phs.Phs;

/**
 * Wrapper for {@link IncidentsManager}, that support local caching for
 * incidents generated by user.
 */
public final class IncidentsProvider {
	private static final Logger logger = LoggerFactory
			.getLogger(IncidentsProvider.class);

	/**
	 * Possible incident states.
	 */
	public enum IncidentState {
		/**
		 * Default state, the way we receive incident from server (untouched).
		 */
		Default,

		/**
		 * Indicates that incident was reported but wasn't confirmed by server
		 */
		Pending,

		/**
		 * Indicates that incident was reported by current user and was
		 * confirmed by server User can now delete an incident.
		 */
		Reported,

		/**
		 * Incident was confirmed by user (valid only for incidents that were
		 * not reported by current user).
		 */
		Confirmed,

		/**
		 * Incident was rejected by user (valid only for incidents that were not
		 * reported by current user).
		 */
		Cleared,

		/**
		 * Incident was deleted, but deletion is not confirmed yet. Incident can
		 * transition to this state only from Pending state. When incident is
		 * deleted while in Reported state it goes into deleted state right
		 * away.
		 */
		DeletePending,

		/**
		 * Incident was deleted by user user. Incidents with this state are no
		 * longer visible to the current user and will be automatically deleted
		 * from local cache after some period of time.
		 */
		Deleted;

		/**
		 * Gets an {@link IncidentState} from specified value.
		 * 
		 * @param index
		 *            Incident state index.
		 * @return Incident state if exists; otherwise default value.
		 */
		public static IncidentState valueOf(int index) {
			IncidentState[] values = IncidentState.values();
			if (index < 0 || index >= values.length) {
				return Default;
			}

			return values[index];
		}
	}
	
	/**
	 * Information about incident cached locally.
	 */
	public static final class LocalIncidentInfo extends Incident {
		private IncidentState state;
		private long reportedTime;
		private long expirationTime;

		/**
		 * Initializes a new instance of {@link LocalIncidentInfo} class.
		 * 
		 * @param state
		 *            Incident state.
		 * @param reportedTime
		 *            Time when incident was reported by the current user.
		 * @param expirationTime
		 *            Time when incident should expire.
		 * @param parent
		 *            Parent incident information.
		 */
		public LocalIncidentInfo(final IncidentState state,
				final long reportedTime, final long expirationTime,
				final Incident parent) {
			super(parent.getId(),
					parent.getVersion(),
					parent.getType(),
					parent.getSeverity(),
					parent.getLatitude(),
					parent.getLongitude(),
					parent.getEventCode(),
					parent.isImpacting(),
					parent.getStartTime(),
					parent.getEndTime(),
					parent.getSource(),
					parent.getShortDescription(),
					parent.getFullDescription(),
					parent.getDelayImpact(),
					parent.getCommunity(),
					parent.getHead(),
					parent.getTails(),
					parent.getLastDetourPoints(),
					parent.getParameterizedDescription());

			this.state = state;
			this.reportedTime = reportedTime;
			this.expirationTime = expirationTime;
		}

		/**
		 * Initializes a new instance of {@link LocalIncidentInfo} class.
		 * 
		 * @param state
		 *            Incident state.
		 * @param parent
		 *            Parent incident information.
		 */
		public LocalIncidentInfo(final IncidentState state,
				final Incident parent) {
			this(state, -1, -1, parent);
		}

		/**
		 * Gets the state of the current incident.
		 * 
		 * @return Incident state.
		 */
		public final IncidentState getState() {
			return this.state;
		}

		/**
		 * Sets the new state for this incident info.
		 * 
		 * @param state
		 *            New incident state.
		 */
		public final void setState(final IncidentState state) {
			this.state = state;
		}

		/**
		 * Gets the time when incident was reported.
		 * 
		 * @return Reported time.
		 */
		public final long getReportedTime() {
			return this.reportedTime;
		}

		/**
		 * Gets the time when incident should expire.
		 * 
		 * @return Incident expiration time.
		 */
		public final long getExpirationTime() {
			return this.expirationTime;
		}
		
		/*
		 * (non-Javadoc)
		 * 
		 * @see com.inrix.sdk.model.Incident#getStartTime()
		 */
		@Override
		public Date getStartTime() {
			if (this.state == IncidentState.Pending) {
				return new Date(this.reportedTime);
			} else {
				return super.getStartTime();
			}
		}
	}
	
	/**
	 * Represents a data adapter for local incidents database.
	 */
	private final class LocalIncidentsDataAdapter {
		/**
		 * Declares tables for local incidents storage.
		 */
		public final class Tables {
			/**
			 * Contains columns for local incidents table.
			 */
			public final class LocalIncidentTable implements BaseColumns {
				// Table name.
				public static final String TABLE_NAME = "LocalIncidents";

				// Fields.
				public static final String INCIDENT_ID = "IncidentId";
				public static final String INCIDENT_STATE = "IncidentState";
				public static final String INCIDENT_REPORTED_TIME = "IncidentReportedTime";
				public static final String INCIDENT_EXPIRATION_TIME = "IncidentExpirationTime";
				public static final String INCIDENT_BLOB = "IncidentBlob";

				/* Create table query */
				public static final String CREATE_QUERY = "CREATE TABLE "
						+ TABLE_NAME + " (" + _ID
						+ " INTEGER PRIMARY KEY AUTOINCREMENT, " + INCIDENT_ID
						+ " INTEGER NOT NULL, " + INCIDENT_STATE
						+ " INTEGER NOT NULL, " + INCIDENT_REPORTED_TIME
						+ " INTEGER NOT NULL, " + INCIDENT_EXPIRATION_TIME
						+ " INTEGER NOT NULL, " + INCIDENT_BLOB + " BLOB);";

				/** Drop table query. */
				public static final String DELETE_QUERY = "DROP TABLE IF EXISTS "
						+ TABLE_NAME + ";";
			}
		}

		/**
		 * Represents a database helper that helps to work with local incidents
		 * database.
		 */
		public final class LocalIncidentDataHelper extends SQLiteOpenHelper {
			/**
			 * Initializes a new instance of the {@link LocalIncidentDataHelper}
			 * .
			 * 
			 * @param context
			 *            Current context.
			 */
			public LocalIncidentDataHelper(final Context context) {
				super(context,
						LOCAL_INCIDENT_DATABASE_NAME,
						null,
						LOCAL_INCIDENT_DATABASE_VERSION);
			}

			/** Current database version. */
			public static final int LOCAL_INCIDENT_DATABASE_VERSION = 1;

			/** Database name. */
			public static final String LOCAL_INCIDENT_DATABASE_NAME = "LocalIncidentsDb.db";

			/*
			 * (non-Javadoc)
			 * 
			 * @see
			 * android.database.sqlite.SQLiteOpenHelper#onCreate(android.database
			 * .sqlite.SQLiteDatabase)
			 */
			@Override
			public void onCreate(final SQLiteDatabase db) {
				logger.trace("Create database: {}",
						LOCAL_INCIDENT_DATABASE_NAME);
				db.execSQL(Tables.LocalIncidentTable.CREATE_QUERY);
			}

			/*
			 * (non-Javadoc)
			 * 
			 * @see
			 * android.database.sqlite.SQLiteOpenHelper#onUpgrade(android.database
			 * .sqlite.SQLiteDatabase, int, int)
			 */
			@Override
			public void onUpgrade(final SQLiteDatabase db,
					final int oldVersion,
					final int newVersion) {
				if (newVersion <= oldVersion) {
					return;
				}

				logger.trace("Upgrade database: {}",
						LOCAL_INCIDENT_DATABASE_NAME);
				db.beginTransaction();

				try {
					db.execSQL(Tables.LocalIncidentTable.DELETE_QUERY);

					this.onCreate(db);
					db.setTransactionSuccessful();
				} finally {
					db.endTransaction();
				}
			}
		}

		private boolean adapterInitialized;
		private final Context adapterContext;
		private LocalIncidentDataHelper dataHelper;

		/**
		 * Initializes a new instance of the {@link LocalIncidentsDataAdapter}
		 * class.
		 * 
		 * @param context
		 *            Current application context.
		 */
		public LocalIncidentsDataAdapter(final Context context) {
			this.adapterContext = context;
		}

		/**
		 * Initializes current local incidents data adapter.
		 */
		public synchronized void initialize() {
			if (this.adapterInitialized) {
				return;
			}

			this.dataHelper = new LocalIncidentDataHelper(this.adapterContext);
			this.adapterInitialized = true;

			logger.trace("Data adapter initialized.");
		}

		/**
		 * Releases any resources being used.
		 */
		public synchronized void release() {
			if (!this.adapterInitialized) {
				return;
			}

			if (this.dataHelper != null) {
				this.dataHelper.close();
				this.dataHelper = null;
			}

			this.adapterInitialized = false;
			logger.trace("Data adapter resources released.");
		}

		/**
		 * Gets the all local incidents.
		 * 
		 * @return All local incidents records.
		 */
		public synchronized Vector<LocalIncidentInfo> getAll() {
			if (!this.adapterInitialized) {
				this.initialize();
			}

			logger.trace("Data adapter getAll called.");

			final Vector<LocalIncidentInfo> items = new Vector<LocalIncidentInfo>();

			// Select all records.
			final SQLiteDatabase database = this.dataHelper
					.getReadableDatabase();
			final Cursor reader = database
					.query(Tables.LocalIncidentTable.TABLE_NAME,
							null,
							null,
							null,
							null,
							null,
							null);

			// Skip empty result set.
			if (reader == null || reader.getCount() == 0) {
				if (reader != null) {
					reader.close();
				}

				return items;
			}

			// Read data.
			try {
				final int columnState = reader
						.getColumnIndex(Tables.LocalIncidentTable.INCIDENT_STATE);
				final int columnReportedTime = reader
						.getColumnIndex(Tables.LocalIncidentTable.INCIDENT_REPORTED_TIME);
				final int columnExpirationTime = reader
						.getColumnIndex(Tables.LocalIncidentTable.INCIDENT_EXPIRATION_TIME);
				final int columnIncidentBlob = reader
						.getColumnIndex(Tables.LocalIncidentTable.INCIDENT_BLOB);

				reader.moveToFirst();
				while (!reader.isAfterLast()) {
					final int stateIndex = reader.getInt(columnState);
					final long reportedTime = reader
							.getLong(columnReportedTime);
					final long expirationTime = reader
							.getLong(columnExpirationTime);
					final byte[] incidentBlob = reader
							.getBlob(columnIncidentBlob);

					final Gson gson = new Gson();
					final LocalIncidentInfo incident = gson
							.fromJson(new String(incidentBlob),
									LocalIncidentInfo.class);

					final LocalIncidentInfo item = new LocalIncidentInfo(IncidentState
							.valueOf(stateIndex),
							reportedTime,
							expirationTime,
							incident);
					items.add(item);

					reader.moveToNext();
				}
			} catch (SQLException ex) {
				items.clear();
			} finally {
				// Release cursor.
				reader.close();
			}

			// Return results.
			return items;
		}

		/**
		 * Gets all pending incidents in the local cache.
		 * 
		 * @return All pending incidents.
		 */
		public final List<LocalIncidentInfo> getPending() {
			final List<LocalIncidentInfo> pending = new Vector<LocalIncidentInfo>();

			final List<LocalIncidentInfo> allItems = this.getAll();
			for (final LocalIncidentInfo current : allItems) {
				if (current.getState() == IncidentState.Pending) {
					pending.add(current);
				}
			}

			return pending;
		}

		/**
		 * Check if item exists in database with specified id.
		 * 
		 * @param id
		 *            Target id to search
		 * @return true, if item was found; otherwise false.
		 */
		public boolean exists(final long id) {
			if (!this.adapterInitialized) {
				this.initialize();
			}

			logger.trace("Checking for incident: {}", id);

			final SQLiteDatabase database = this.dataHelper
					.getReadableDatabase();
			final String[] columns = new String[] { BaseColumns._ID,
					Tables.LocalIncidentTable.INCIDENT_ID };
			final String where = "[" + Tables.LocalIncidentTable.INCIDENT_ID
					+ "] = ?";
			final String[] whereArgs = new String[] { String.valueOf(id) };

			final SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
			builder.setTables(Tables.LocalIncidentTable.TABLE_NAME);

			final String query = builder.buildQuery(columns,
					where,
					null,
					null,
					null,
					null);
			final Cursor reader = database.rawQuery(query, whereArgs);

			// Check result reader first.
			if (reader == null || reader.getCount() == 0) {
				if (reader != null) {
					reader.close();
				}

				logger.trace("Incident with id {} wasn't found.", id);
				return false;
			}

			if (reader.getCount() == 1) {
				logger.trace("Incident with id {} was found.", id);
				reader.close();
				return true;
			}

			logger.trace("Incident with id {} wasn't found.", id);
			reader.close();
			return false;
		}

		/**
		 * Update item in the database.
		 * 
		 * @param item
		 *            Target item to update.
		 */
		public void update(final LocalIncidentInfo item) {
			if (!this.adapterInitialized) {
				this.initialize();
			}

			logger.trace("Updating local incident information: {}", item);

			final SQLiteDatabase database = this.dataHelper
					.getWritableDatabase();
			database.beginTransaction();

			try {
				final Gson gson = new Gson();
				final byte[] incidentBlob = gson.toJson(item).getBytes();

				final ContentValues values = new ContentValues();
				values.put(Tables.LocalIncidentTable.INCIDENT_STATE, item
						.getState().ordinal());
				values.put(Tables.LocalIncidentTable.INCIDENT_REPORTED_TIME,
						item.getReportedTime());
				values.put(Tables.LocalIncidentTable.INCIDENT_EXPIRATION_TIME,
						item.getExpirationTime());
				values.put(Tables.LocalIncidentTable.INCIDENT_BLOB,
						incidentBlob);

				final String whereClause = Tables.LocalIncidentTable.INCIDENT_ID
						+ " = ?";
				final String[] whereArgs = new String[] { String.valueOf(item
						.getId()) };

				final int rowsAffected = database
						.update(Tables.LocalIncidentTable.TABLE_NAME,
								values,
								whereClause,
								whereArgs);
				if (rowsAffected == 1) {
					logger.trace("Local incident was successfully updated.");
					database.setTransactionSuccessful();
				} else {
					logger.warn("Failed to update local incident.");
				}
			} finally {
				database.endTransaction();
			}
		}

		/**
		 * Creates the new item in the database.
		 * 
		 * @param item
		 *            The instance to create record from.
		 */
		public final void create(final LocalIncidentInfo item) {
			if (!this.adapterInitialized) {
				this.initialize();
			}

			logger.trace("Creaing local incident: {}", item);

			final SQLiteDatabase database = this.dataHelper
					.getWritableDatabase();
			database.beginTransaction();

			try {
				final Gson gson = new Gson();
				final byte[] incidentBlob = gson.toJson(item).getBytes();

				final ContentValues values = new ContentValues();
				values.put(Tables.LocalIncidentTable.INCIDENT_ID, item.getId());
				values.put(Tables.LocalIncidentTable.INCIDENT_STATE, item
						.getState().ordinal());
				values.put(Tables.LocalIncidentTable.INCIDENT_REPORTED_TIME,
						item.getReportedTime());
				values.put(Tables.LocalIncidentTable.INCIDENT_EXPIRATION_TIME,
						item.getExpirationTime());
				values.put(Tables.LocalIncidentTable.INCIDENT_BLOB,
						incidentBlob);

				final long id = database
						.insert(Tables.LocalIncidentTable.TABLE_NAME,
								null,
								values);
				if (id >= 0) {
					logger.trace("Local incident was successfully created.");
					database.setTransactionSuccessful();
				} else {
					logger.warn("Failed to create local incident.");
				}
			} finally {
				database.endTransaction();
			}
		}

		/**
		 * Gets the item by ID.
		 * 
		 * @param id
		 *            Target incident ID.
		 * @return {@see LocalIncidentInfo} instance, if exists; otherwise null.
		 */
		public final LocalIncidentInfo getItem(final long id) {
			if (!this.adapterInitialized) {
				this.initialize();
			}

			logger.trace("Getting incident by id: {}", id);

			// Select record.
			final String whereClause = Tables.LocalIncidentTable.INCIDENT_ID
					+ " = ?";
			final String[] whereArgs = new String[] { String.valueOf(id) };
			final SQLiteDatabase database = this.dataHelper
					.getReadableDatabase();
			final Cursor reader = database
					.query(Tables.LocalIncidentTable.TABLE_NAME,
							null,
							whereClause,
							whereArgs,
							null,
							null,
							null);

			// Skip empty result set.
			if (reader == null || reader.getCount() == 0) {
				if (reader != null) {
					reader.close();
				}

				logger.trace("Local incident with id {} wasn't found.", id);
				return null;
			}

			// Read data.
			try {
				final int columnState = reader
						.getColumnIndex(Tables.LocalIncidentTable.INCIDENT_STATE);
				final int columnReportedTime = reader
						.getColumnIndex(Tables.LocalIncidentTable.INCIDENT_REPORTED_TIME);
				final int columnExpirationTime = reader
						.getColumnIndex(Tables.LocalIncidentTable.INCIDENT_EXPIRATION_TIME);
				final int columnIncidentBlob = reader
						.getColumnIndex(Tables.LocalIncidentTable.INCIDENT_BLOB);

				reader.moveToFirst();

				final int stateIndex = reader.getInt(columnState);
				final long reportedTime = reader.getLong(columnReportedTime);
				final long expirationTime = reader
						.getLong(columnExpirationTime);
				final byte[] incidentBlob = reader.getBlob(columnIncidentBlob);

				final Gson gson = new Gson();
				final LocalIncidentInfo incident = gson
						.fromJson(new String(incidentBlob),
								LocalIncidentInfo.class);

				final LocalIncidentInfo item = new LocalIncidentInfo(IncidentState
						.valueOf(stateIndex),
						reportedTime,
						expirationTime,
						incident);

				logger.trace("Incident obtained: {}.", item);
				return item;
			} finally {
				// Release cursor.
				reader.close();
			}
		}

		/**
		 * Delete local incident by given ID.
		 * 
		 * @param id
		 *            Target local incident ID.
		 */
		@SuppressWarnings("unused")
		public final void delete(final long id) {
			if (!this.adapterInitialized) {
				this.initialize();
			}

			logger.trace("Deleting local incident with id: {}.", id);

			final SQLiteDatabase database = this.dataHelper
					.getWritableDatabase();
			database.beginTransaction();

			try {
				final String whereClause = Tables.LocalIncidentTable.INCIDENT_ID
						+ " = ?";
				final String[] whereArgs = new String[] { String.valueOf(id) };
				final int rowsAffected = database
						.delete(Tables.LocalIncidentTable.TABLE_NAME,
								whereClause,
								whereArgs);

				if (rowsAffected > 0) {
					logger.trace("Local incident deleted: {}.", id);
				} else {
					logger.warn("Failed to delete local incident: {}.", id);
				}

				database.setTransactionSuccessful();
			} finally {
				database.endTransaction();
			}
		}

		/**
		 * Delete all rows from the incidents table by given IDs.
		 * 
		 * @param ids
		 *            List of IDs to delete.
		 */
		public final void deleteAll(final Long[] ids) {
			if (!this.adapterInitialized) {
				this.initialize();
			}

			logger.trace("Deleting all local incidents by ids: {}.",
					TextUtils.join(",", ids));

			final SQLiteDatabase database = this.dataHelper
					.getWritableDatabase();
			database.beginTransaction();

			try {
				final String whereClause = Tables.LocalIncidentTable.INCIDENT_ID
						+ " IN (" + this.generatePlaceholders(ids.length) + ")";
				final String[] whereArgs = Arrays.toString(ids)
						.split("[\\[\\]]")[1].split(", ");
				final int rowsAffected = database
						.delete(Tables.LocalIncidentTable.TABLE_NAME,
								whereClause,
								whereArgs);

				if (rowsAffected > 0) {
					logger.trace("Local incidents deleted: {}.",
							TextUtils.join(",", ids));
				} else {
					logger.warn("Failed to delete local incidents: {}.",
							TextUtils.join(",", ids));
				}

				database.setTransactionSuccessful();
			} finally {
				database.endTransaction();
			}
		}

		/**
		 * Generates specified number of placeholders for a query.
		 * 
		 * @param length
		 *            Number of placeholders.
		 * @return String with placeholders.
		 */
		private final String generatePlaceholders(final int length) {
			final StringBuilder sb = new StringBuilder(length * 2 - 1);
			sb.append("?");

			for (int index = 1; index < length; index++) {
				sb.append(",?");
			}

			return sb.toString();
		}
	}

	/**
	 * An action to save local incident.
	 */
	private class SaveLocalIncidentRunnable implements Runnable {
		private final Incident incident;
		private final IncidentState state;

		/**
		 * Initializes a new instance of the {@link SaveLocalIncidentRunnable}
		 * class.
		 * 
		 * @param incident
		 *            Target incident to save.
		 * @param state
		 *            Current incident state.
		 */
		public SaveLocalIncidentRunnable(final Incident incident,
				final IncidentState state) {
			this.incident = incident;
			this.state = state;
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Runnable#run()
		 */
		@Override
		public final void run() {
			if (dataAdapter == null) {
				logger.warn("Data adapter is null. Can't create local incident.");
				return;
			}

			synchronized (dataAdapter) {
				final boolean exists = dataAdapter
						.exists(this.incident.getId());
				final long reportedTime = !exists ? DateUtils
						.getCurrentTimeUtcMillis() : dataAdapter
						.getItem(this.incident.getId()).getReportedTime();
				final long expirationTime = resolveExpirationTime(this.incident
						.getEndTime());

				final LocalIncidentInfo item = new LocalIncidentInfo(this.state,
						reportedTime,
						expirationTime,
						this.incident);

				if (dataAdapter.exists(this.incident.getId())) {
					dataAdapter.update(item);
				} else {
					dataAdapter.create(item);
				}

				dataAdapter.release();
			}
		}
	}

	/**
	 * An action to delete local incident.
	 */
	private class DeleteLocalIncidentRunnable implements Runnable {
		private List<Incident> incidents;

		/**
		 * Initializes a new instance of {@link DeleteLocalIncidentRunnable}
		 * class.
		 * 
		 * @param incidents
		 *            An incidents to delete.
		 */
		private DeleteLocalIncidentRunnable(final List<Incident> incidents) {
			this.incidents = incidents;
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Runnable#run()
		 */
		@Override
		public final void run() {
			final Long[] ids = new Long[this.incidents.size()];

			for (int index = 0; index < ids.length; index++) {
				ids[index] = this.incidents.get(index).getId();
			}

			synchronized (dataAdapter) {
				dataAdapter.deleteAll(ids);
				dataAdapter.release();
			}
		}
	}

	public static final long INCIDENT_DEFAULT_EXPIRATION = 36000000;

	private IncidentsManager manager;
	private LocalIncidentsDataAdapter dataAdapter;
	private ICancellable currentRequest;
	private ExecutorService executor;
	private Handler handler;

	/**
	 * Initializes a new instance of {@link IncidentsProvider} class.
	 */
	public IncidentsProvider() {
		this.manager = InrixCore.getIncidentsManager();
		this.executor = Executors.newFixedThreadPool(5);
		this.handler = new Handler(Looper.getMainLooper());
	}

	/**
	 * Necessary preparations before retrieving the data.
	 */
	private final void prepare() {
		this.release();

		if (this.dataAdapter == null) {
			this.dataAdapter = new LocalIncidentsDataAdapter(TrafficApp.getContext());
		}

		logger.debug("Prepared.");
	}

	/**
	 * Gets incidents based on specified arguments, mix with local incidents.
	 * 
	 * @param options
	 *            Incidents request options.
	 * @param listener
	 *            Response listener.
	 */
	public final void getIncidentsAsync(final IncidentsManager.IncidentBoxOptions options,
			final IncidentsManager.IIncidentsResponseListener listener) {
		logger.debug("getIncidentAsync[box]");
		this.prepare();

		this.currentRequest = this.manager.getIncidentsInBox(options,
				new IncidentsManager.IIncidentsResponseListener() {
					@Override
					public final void onResult(final List<Incident> result) {
						mixinWithLocalIncidents(result, listener);
					}

					@Override
					public final void onError(final Error error) {
						listener.onError(error);
					}
				});
	}

	/**
	 * Gets incidents based on specified arguments, mix with local incidents.
	 * 
	 * @param options
	 *            Incidents request options.
	 * @param listener
	 *            Response listener.
	 */
	public final void getIncidentsAsync(final IncidentsManager.IncidentRadiusOptions options,
			final IncidentsManager.IIncidentsResponseListener listener) {
		logger.debug("getIncidentsAsync[radius]");
		this.prepare();

		this.currentRequest = this.manager.getIncidentsInRadius(options,
				new IncidentsManager.IIncidentsResponseListener() {
					@Override
					public final void onResult(final List<Incident> result) {
						mixinWithLocalIncidents(result, listener);
					}

					@Override
					public final void onError(final Error error) {
						listener.onError(error);
					}
				});
	}

	/**
	 * Report incidents using specified parameters.
	 * 
	 * @param options
	 *            Incident report options.
	 * @param listener
	 *            Response listener.
	 */
	public final void reportIncident(final IncidentsManager.IncidentReportOptions options,
			final IncidentsManager.IIncidentReportListener listener) {
		logger.debug("Reporting incident.");
		this.prepare();

		this.currentRequest = this.manager.reportIncident(options,
				new IncidentsManager.IIncidentReportListener() {
					@Override
					public final void onResult(final Incident result) {
						final LocalIncidentInfo local = new LocalIncidentInfo(IncidentState.Pending,
								DateUtils.getCurrentTimeUtcMillis(),
								resolveExpirationTime(null),
								createLocalIncidentFromReportOptions(options,
										result));

						logger.debug("Local reported incident: {}", local);

						executor.submit(new SaveLocalIncidentRunnable(local,
								IncidentState.Pending));

						postIncidentStateChangeEvent(new IncidentStateChangedEvent(local,
								IncidentState.Pending));

						listener.onResult(local);
					}

					@Override
					public final void onError(final Error error) {
						listener.onError(error);
					}
				});
	}

	/**
	 * Confirm / reject incident using specified parameters.
	 * 
	 * @param options
	 *            Incident review parameters.
	 * @param listener
	 *            Response listener.
	 * @param incident
	 *            Incident information.
	 */
	public final void reviewIncident(final IncidentsManager.IncidentReviewOptions options,
			final IncidentsManager.IIncidentReviewListener listener,
			final Incident incident) {
		logger.debug("Reviewing incident.");
		this.prepare();

		this.currentRequest = this.manager.reviewIncident(options,
				new IncidentsManager.IIncidentReviewListener() {
					@Override
					public final void onResult(final Boolean result) {
						final IncidentState state = ReflectionUtils
								.<Boolean> getValueFromObject(options,
										"confirmed") ? IncidentState.Confirmed
								: IncidentState.Cleared;
						executor.submit(new SaveLocalIncidentRunnable(incident,
								state));

						postIncidentStateChangeEvent(new IncidentStateChangedEvent(incident,
								state));

						listener.onResult(result);
					}

					@Override
					public final void onError(final Error error) {
						listener.onError(error);
					}
				});
	}

	/**
	 * Delete incident using specified parameters.
	 * 
	 * @param options
	 *            Incident delete request parameters.
	 * @param listener
	 *            Response listener.
	 */
	public final void deleteIncident(final IncidentsManager.IncidentDeleteOptions options,
			final IncidentsManager.IIncidentDeleteListener listener) {
		logger.debug("Deleting incident.");

		this.prepare();

		this.currentRequest = this.manager.deleteIncident(options,
				new IncidentsManager.IIncidentDeleteListener() {
					@Override
					public final void onResult(final Boolean result) {
						executor.submit(new Runnable() {
							@Override
							public final void run() {
								final long id = ReflectionUtils
										.<Long> getValueFromObject(options,
												"incidentId");
								synchronized (dataAdapter) {
									final LocalIncidentInfo info = dataAdapter
											.getItem(id);
									if (info != null) {
										info.setState(IncidentState.DeletePending);
										dataAdapter.update(info);
										dataAdapter.release();

										postIncidentStateChangeEvent(new IncidentStateChangedEvent(info,
												IncidentState.DeletePending));
									}
								}
							}
						});

						listener.onResult(result);
					}

					@Override
					public final void onError(final Error error) {
						listener.onError(error);
					}
				});
	}

	/**
	 * Cleanup expired local incidents.
	 */
	public synchronized void cleanupExpired() {
		this.prepare();

		this.executor.execute(new Runnable() {
			@Override
			public void run() {
				try {
					synchronized (dataAdapter) {
						final long timeMillis = DateUtils
								.getCurrentTimeUtcMillis();
						final List<LocalIncidentInfo> items = dataAdapter
								.getAll();
						final List<Long> ids = new Vector<Long>();

						for (final LocalIncidentInfo item : items) {
							if ( (item.getExpirationTime() - timeMillis) <= 0) {
								ids.add(item.getId());
							}
						}

						if (ids.isEmpty()) {
							return;
						}

						dataAdapter.deleteAll(ids.toArray(new Long[0]));
						dataAdapter.release();
					}
				} catch (Exception ex) {
					logger.warn("Error clearing expired incidents.", ex);
				}

			}
		});
	}

	/**
	 * Release resources used by current provider.
	 */
	public void release() {
		logger.debug("Releasing resources.");
		if (this.dataAdapter != null) {
			this.dataAdapter.release();
		}

		if (this.currentRequest != null) {
			this.currentRequest.cancel();
			this.currentRequest = null;
		}
	}

	/**
	 * Filter received incidents with locally cached incidents.
	 * 
	 * @param result
	 *            Incidents collection (received from getIncidentsAsync
	 *            request).
	 * @param listener
	 *            Response listener.
	 */
	private final void mixinWithLocalIncidents(final List<Incident> result,
			final IncidentsManager.IIncidentsResponseListener listener) {
		// Return immediatelly, if there are no incidents to process.
		if (result == null) {
			listener.onResult(null);
			return;
		}

		this.executor.submit(new Runnable() {
			@Override
			public void run() {
				try {
					final List<Incident> filtered = new Vector<Incident>();
					final List<Incident> incidentsToRemove = new Vector<Incident>();

					// Process received results.
					for (final Incident current : result) {
						IncidentState state = IncidentState.Default;
						final LocalIncidentInfo local = dataAdapter
								.getItem(current.getId());
						if (local != null) {
							state = local.getState();
							switch (local.getState()) {
								case Pending:
									executor.submit(new SaveLocalIncidentRunnable(current,
											IncidentState.Reported));
									break;
								case Deleted:
									// Skip deleted incidents.
									continue;
								case DeletePending:
									incidentsToRemove.add(current);
									continue;
								case Reported:
								case Cleared:
								case Confirmed:
								default:
									break;
							}
						}

						filtered.add(new LocalIncidentInfo(state, current));
					}

					// Handle pending incidents separately.
					final List<LocalIncidentInfo> pending = dataAdapter
							.getPending();
					for (final LocalIncidentInfo current : pending) {
						logger.debug("Adding pending incident: {}", current);
						filtered.add(current);
					}

					// Publish results.
					handler.post(new Runnable() {
						@Override
						public void run() {
							listener.onResult(filtered);
						}
					});

					// Schedule incidents removal for incidents that are in
					// "DeletePending" state.
					if (!incidentsToRemove.isEmpty()) {
						executor.submit(new DeleteLocalIncidentRunnable(incidentsToRemove));
					}
				} catch (final Exception ex) {
					logger.error("{}", ex);
				}
			}
		});
	}

	private final Incident createLocalIncidentFromReportOptions(final IncidentsManager.IncidentReportOptions options,
			final Incident original) {
		// Since all we get back from report incident is incident ID, we need to
		// manually fill in other details so we can use the
		// incident that we got back.

		// TODO: Consider doing this on SDK, until we get better solution from
		// MoSI.
		final Incident incident = new Incident(original.getId(),
				1,
				ReflectionUtils.<Integer> getValueFromObject(options,
						"incidentType"),
				0,
				ReflectionUtils.<Phs> getValueFromObject(options,
						"location").getLatitude(),
				ReflectionUtils.<Phs> getValueFromObject(options,
						"location").getLongitude(),
				ReflectionUtils.<Integer> getValueFromObject(options,
						"eventCode"),
				false,
				null,
				null,
				null,
				null,
				null);
		return incident;
	}

	/**
	 * Gets the incident expiration time.
	 * 
	 * @param endTime
	 *            the end time
	 * @return the incident expiration time
	 */
	private static long resolveExpirationTime(final Date endTime) {
		if (endTime == null) {
			return DateUtils.getCurrentTimeUtcMillis()
					+ INCIDENT_DEFAULT_EXPIRATION;
		}

		try {
			return endTime.getTime();
		} catch (Exception e) {
			return DateUtils.getCurrentTimeUtcMillis()
					+ INCIDENT_DEFAULT_EXPIRATION;
		}
	}

	private final void postIncidentStateChangeEvent(final IncidentStateChangedEvent event) {
		this.handler.post(new Runnable() {
			@Override
			public void run() {
				TrafficApp.getBus().post(event);
			}
		});
	}

	private static final class ReflectionUtils {
		@SuppressWarnings("unchecked")
		public static final <T> T getValueFromObject(final Object target,
				final String fieldName) {
			try {
				Field field;
				Class<?> clazz = target.getClass();
				while (clazz != null) {
					try {
						field = clazz.getDeclaredField(fieldName);
						field.setAccessible(true);
						return (T) field.get(target);
					} catch (SecurityException e) {
						e.printStackTrace();
					} catch (NoSuchFieldException e) {
						clazz = clazz.getSuperclass();
					}
				}
			} catch (Exception e) {
				e.printStackTrace();
			}

			return (T) null;
		}
	}
}